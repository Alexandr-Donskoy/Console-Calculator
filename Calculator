import re


class Calculator:
    def __init__(self):
        self.tokens = []
        self.pos = 0

    def validate_expression(self, expression): # Проверка по строкам

        if not expression.strip():
            raise ValueError("Пустое выражение")


        valid_chars = r'[\d\+\-\*\/\(\)\.\s]'
        invalid_chars = re.findall(f'[^{valid_chars[1:]}', expression)
        if invalid_chars:
            raise ValueError(f"Недопустимые символы: {set(invalid_chars)}")


        if re.search(r'\d+\.\d*\.', expression):
            raise ValueError("Некорректное число с множественными точками")


        if re.search(r'\d+\.(?!\d)', expression):
            raise ValueError("Некорректное число: точка без дробной части")


        bracket_stack = []
        for i, char in enumerate(expression):
            if char == '(':
                bracket_stack.append(i)
            elif char == ')':
                if not bracket_stack:
                    raise ValueError("Непарная закрывающая скобка")
                bracket_stack.pop()
        if bracket_stack:
            raise ValueError("Непарная открывающая скобка")


        cleaned = expression.replace(' ', '')
        if cleaned and cleaned[0] in ['*', '/']:
            raise ValueError("Выражение не может начинаться с оператора * или /")
        if cleaned and cleaned[-1] in ['+', '-', '*', '/']:
            raise ValueError("Выражение не может заканчиваться оператором")

        return True

    def validate_tokens(self, tokens): # Проверка по токенам
        if not tokens:
            raise ValueError("Нет токенов для вычисления")

        for i in range(len(tokens) - 1):

            current = tokens[i]
            next_token = tokens[i + 1]

            if current in ['+', '-', '*', '/']:
                if next_token in ['+', '-']:
                    raise ValueError(
                        f"После оператора '{current}' не может идти оператор '{next_token}', если оператор '{next_token}' унарный - пожалуйста, поставьте скобки")
                if next_token in ['*', '/']:
                    raise ValueError(f"После оператора '{current}' не может идти оператор '{next_token}'")


            if re.match(r'\d+\.?\d*', current) and next_token == '(':
                raise ValueError(f"После числа '{current}' не может идти открывающую скобку")


            if current == ')' and re.match(r'\d+\.?\d*', next_token):
                raise ValueError(f"После закрывающей скобки не может идти число '{next_token}'")


            if current == '(' and next_token in ['*', '/']:
                raise ValueError(f"После открывающей скобки не может идти оператор '{next_token}'")

        return True

    def tokenize(self, expression): # Разбиение на токены

        expression_no_spaces = expression.replace(' ', '')
        token_pattern = r'\d+\.?\d*|[\+\-\*\/\(\)]'
        tokens = re.findall(token_pattern, expression_no_spaces)


        remaining = re.sub(token_pattern, '', expression_no_spaces)
        if remaining:
            raise ValueError(f"Нераспознанные символы: '{remaining}'")

        self.validate_tokens(tokens)
        return tokens

    def get_current_token(self): # Возвращает текущий токен
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        return None

    def consume_token(self): # Перемещает указатель на следующий токен
        self.pos += 1

    def factor(self):
        token = self.get_current_token()

        if token is None:
            raise ValueError("Конец выражения")


        if token == '+' or token == '-':
            self.consume_token()
            value = self.factor()
            if token == '+':
                return value
            else:
                return -value


        if re.match(r'^\d+\.?\d*$', token):
            self.consume_token()
            return float(token)


        if token == '(':
            self.consume_token()
            result = self.expr()
            if self.get_current_token() != ')':
                raise ValueError("Ожидается закрывающая скобка")
            self.consume_token()
            return result

        raise ValueError(f"Неожиданный токен: '{token}'")

    def term(self): # Умножение и деление

        result = self.factor()

        while True:
            token = self.get_current_token()
            if token != '*' and token != '/':
                break

            self.consume_token()
            right = self.factor()

            if token == '*':
                result = result * right
            elif token == '/':
                if right == 0:
                    raise ValueError("Деление на ноль")
                result = result / right

        return result

    def expr(self): # Сложение и вычитание

        result = self.term()

        while True:
            token = self.get_current_token()
            if token != '+' and token != '-':
                break

            self.consume_token()
            right = self.term()

            if token == '+':
                result = result + right
            elif token == '-':
                result = result - right

        return result

    def calculate(self, expression): # Основная функция
        try:

            self.validate_expression(expression)


            self.tokens = self.tokenize(expression)
            self.pos = 0


            result = self.expr()


            if self.pos != len(self.tokens):
                next_token = self.get_current_token()
                raise ValueError(f"Некорректное выражение - необработанные токены, начиная с: '{next_token}'")

            return result

        except Exception as e:
            raise ValueError(f"Ошибка вычисления: {str(e)}")


def run_comprehensive_tests(): # Тестирование
    calculator = Calculator()

    # Тесты на правильные выражения
    correct_cases = [
        ("2+3", 5),
        ("10-4", 6),
        ("3*4", 12),
        ("15/3", 5),
        ("2+3*4", 14),
        ("(2+3)*4", 20),
        ("-5+3", -2),
        ("3.5+2.5", 6.0),
        ("10/2*3", 15),
        ("-(-3)", 3),
        ("0.5*2", 1.0),
    ]

    # Тесты на выражения с ошибками
    error_cases = [
        "2+*3",
        "3*/4",
        "*5",
        "5+",
        "3++4",
        "3..4",
        "2 + 3a",
        "(2+3",
        "2+3)",
        "2(*3)",
        "3(4)",
        "2)3",
        ")(",
        "",
        "5 / 0",
        "1.2.3",
        "123.",
    ]

    print("ТЕСТИРОВАНИЕ КОРРЕКТНЫХ ВЫРАЖЕНИЙ:")
    print("=" * 50)

    all_passed = True
    for expression, expected in correct_cases:
        try:
            result = calculator.calculate(expression)

            if abs(result - expected) < 0.000001:
                status = "PASS"
            else:
                status = "FAIL"
            print(f"{expression:15} = {result:8} (ожидается: {expected:8}) [{status}]")

            if status == "FAIL":
                all_passed = False

        except Exception as e:
            print(f"{expression:15} = ОШИБКА: {e} [FAIL]")
            all_passed = False

    print("\nТЕСТИРОВАНИЕ ОШИБОЧНЫХ ВЫРАЖЕНИЙ:")
    print("=" * 50)

    for expression in error_cases:
        try:
            result = calculator.calculate(expression)
            print(f"{expression:15} = {result:8} [FAIL - ожидалась ошибка]")
            all_passed = False
        except Exception as e:
            print(f"{expression:15} = ОШИБКА: {e} [PASS]")

    print("=" * 50)
    if all_passed:
        print("Результат: Все тесты пройдены!")
    else:
        print("Результат: Есть ошибки!")

    return all_passed


def main():
    calculator = Calculator()

    print("Консольный калькулятор, задание E1")
    print("Поддерживаемые операции: +, -, *, /, унарные +/-, скобки")
    print("Команды:")
    print("  'quit' - выход")
    print("  'test' - запуск тестов")
    print("-" * 60)

    while True:
        try:
            user_input = input("Введите выражение или команду: ").strip()

            if user_input.lower() == 'quit':
                break
            elif user_input.lower() == 'test':
                run_comprehensive_tests()
                continue
            elif not user_input:
                continue

            result = calculator.calculate(user_input)
            print(f"Результат: {result}")

        except ValueError as e:
            print(f"Ошибка: {e}")
        except KeyboardInterrupt:
            print("\nВыход из программы")
            break
        except Exception as e:
            print(f"Неизвестная ошибка: {e}")


if __name__ == "__main__":
    main()
